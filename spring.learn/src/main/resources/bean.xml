<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:tx="http://www.springframework.org/schema/tx"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd
http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd">
    <!-- 所谓的Spring容器
        实际上就是一堆bean的map，
    -->
    <!-- 创建Bean的三种方式 -->
    <!--
        第一种，使用类的默认构造函数构建，如果没有默认构造函数，且除了id和class
        属性外不传递其它参数则无法构建bean对象，最终无法创建bean对象
        第二种: 使用类中的方法创建对象并存入spirng容器
    -->
    <!-- 第一种-->
    <bean id="userService" class="zzc.service.IUserServiceImpl"></bean>
    <!--第二种，
        指定创建类的类的以及其中哪个方法创建对象
        factory-bean指定创建类的工厂(类)
        factory-method指定使用的创建方法
    -->
    <bean id="user" factory-bean="userService"  factory-method="getUser" scope="singleton"></bean>
    <!-- 第三种:
        使用工厂方法的静态方法创建对象,只需要指明对应的静态类所在的class以及采用的哪个静态方法即可
     -->
    <bean id="users" class="zzc.service.IUserServiceImpl" factory-method="getUsers" scope="prototype"></bean>

    <!-- bean的作用范围 -->
    <!--
        通过bean的scope属性来指定bean的作用范围:
            取值:
                singleton 单例（默认）
                prototype 多例
                request web应用的请求范围
                session web应用的会话范围
                global-session 集群环境的会话范围
    -->

    <!-- bean对象的生命周期 -->
    <!--
        单例对象：
              出生：容器创建时
              活着：容器存在则对象存在
              死亡：容器销毁对象消亡
        多例对象：
            出生：调用时候创建
            活着: 只要再使用就一直活着
            死亡：对象长时间不用后且没有别的对象引用时，有Java垃圾回收机制回收
    -->

    <!-- spring依赖注入
        (1) 注入的实体是不经常变化的    -->
    <!--
        spring中的依赖注入:
        依赖注入:
            Dependency Injection
        IOC的作用：
            降低程序的耦合（依赖关系）
        依赖关系的管理：
            通过Spring容器进行管理,反转控制
        依赖注入的数据:
            基本类型和string
            其它bean类型
            复杂类型/集合类型
            注入方法：
                使用构造方法
                使用set方法
                使用注解提供
    -->
    <!-- 构造函数注入
        使用constructor-arg
        标签出现的位置: bean标签的内部
        标签的属性:
        TYPE:用于指定要注入的数据的数据类型
        该数据类型也是构造函数中某个或某些参数的裂隙
        index用于指定要注入数据再构造函数中的位置


     -->
    <bean id="userConstructor" class="zzc.service.IUserServiceImpl">
        <constructor-arg name="s" value="1"></constructor-arg>
    </bean>
    <!-- set注入 根据实体类的get/set方法进行注入
           直接通过默认构造函数
           name指明注入的set名称
         弊端：
            某个成员必须有值，则获取对象时可能无值
    -->
    <bean id="userSet" class="zzc.service.IUserServiceImpl">
        <property name="a" value="1"></property>
    </bean>
    <!-- 对于集合类型成员的注入  通过set注入-->
    <bean id="userCollection" class="zzc.domain.TestCollection">
        <!-- 通过指明数据类型来通过集合进行赋值 -->
        <property name="list">
            <list>
                <value>1</value>
                <value>2</value>
            </list>
        </property>
        <property name="map">
            <map>
                <entry key="1" value="2"></entry>
            </map>
        </property>
        <property name="set">
            <set>
                <value>1</value>
                <value>2</value>
            </set>
        </property>
    </bean>
</beans>